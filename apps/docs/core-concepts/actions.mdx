---
title: "Actions"
description: "Building blocks of AI workflows in Spinai"
---

## Understanding Actions

Actions are the fundamental building blocks in Spinai that perform specific tasks. Each action is a modular, reusable component that can be orchestrated to create complex AI workflows.

## Creating Actions

### Basic Action Structure

```typescript
import type { ActionModule } from "spinai";

export const config = {
  id: "myAction",
  metadata: {
    description: "Performs a specific task",
  },
};

export async function run(context) {
  // Implementation
  return result;
}
```

### Full Action Example

```typescript
import type { ActionModule, ActionContext } from "spinai";

export const config = {
  id: "textAnalyzer",
  dependsOn: ["preprocessor"],
  allowRerun: false,
  retries: 3,
  metadata: {
    description: "Analyzes text for sentiment and key topics",
    version: "1.0.0",
    author: "Your Name",
  },
};

export async function run(context: ActionContext) {
  const { input } = context.request;
  const { preprocessor } = context.store;

  // Implementation
  const analysis = await analyzeText(input, preprocessor);

  return {
    sentiment: analysis.sentiment,
    topics: analysis.topics,
  };
}
```

## Action Configuration

### Configuration Options

```typescript
interface ActionConfig {
  id: string; // Unique identifier
  dependsOn?: string[]; // Action dependencies
  allowRerun?: boolean; // Can action run multiple times?
  retries?: number; // Number of retry attempts
  metadata?: {
    description?: string; // Action description
    [key: string]: any; // Additional metadata
  };
}
```

### Dependencies

Specify actions that must run before this action:

```typescript
export const config = {
  id: "summarizer",
  dependsOn: ["textAnalyzer", "topicExtractor"],
  metadata: {
    description: "Creates a summary based on analysis and topics",
  },
};
```

## Context and State

### Action Context

```typescript
interface ActionContext {
  request: {
    input: string;
    metadata?: Record<string, any>;
  };
  store: Record<string, any>;
  actions: Record<string, ActionModule>;
}
```

### Using Context

```typescript
export async function run(context: ActionContext) {
  // Access user input
  const { input } = context.request;

  // Access results from dependent actions
  const { analysis } = context.store;

  // Access other actions
  const otherAction = context.actions.someAction;

  // Return results
  return processedResult;
}
```

## Best Practices

### 1. Single Responsibility

Keep actions focused on one specific task:

```typescript
// Good
export const config = {
  id: "sentimentAnalyzer",
  metadata: {
    description: "Analyzes text sentiment",
  },
};

// Avoid
export const config = {
  id: "textProcessor",
  metadata: {
    description: "Analyzes sentiment, extracts topics, and summarizes",
  },
};
```

### 2. Error Handling

Implement robust error handling:

```typescript
export async function run(context: ActionContext) {
  try {
    const result = await processData(context.request.input);
    return result;
  } catch (error) {
    throw new Error(`Failed to process data: ${error.message}`);
  }
}
```

### 3. Validation

Validate inputs and outputs:

```typescript
export async function run(context: ActionContext) {
  // Validate input
  if (!context.request.input) {
    throw new Error("Input is required");
  }

  // Process
  const result = await processData(context.request.input);

  // Validate output
  if (!isValidResult(result)) {
    throw new Error("Invalid result");
  }

  return result;
}
```

## Advanced Patterns

### Composable Actions

Create actions that work well together:

```typescript
// Action 1: Text Analysis
export const textAnalyzer = {
  config: {
    id: "textAnalyzer",
  },
  run: async (context) => ({
    sentiment: analyzeSentiment(context.request.input),
    topics: extractTopics(context.request.input),
  }),
};

// Action 2: Summarization
export const summarizer = {
  config: {
    id: "summarizer",
    dependsOn: ["textAnalyzer"],
  },
  run: async (context) => {
    const { sentiment, topics } = context.store.textAnalyzer;
    return generateSummary(context.request.input, { sentiment, topics });
  },
};
```

### Stateful Actions

Manage state between runs:

```typescript
let actionState = new Map();

export async function run(context: ActionContext) {
  const stateKey = context.request.metadata?.sessionId;
  const previousState = actionState.get(stateKey);

  // Process with state
  const result = await processWithState(context.request.input, previousState);

  // Update state
  actionState.set(stateKey, result.newState);

  return result.output;
}
```

## Examples

### Text Processing Action

```typescript
export const config = {
  id: "textProcessor",
  metadata: {
    description: "Processes text for analysis",
  },
};

export async function run(context: ActionContext) {
  const { input } = context.request;

  // Clean text
  const cleaned = removeSpecialCharacters(input);

  // Tokenize
  const tokens = tokenize(cleaned);

  // Process
  const processed = await process(tokens);

  return {
    cleaned,
    tokens,
    processed,
  };
}
```

### API Integration Action

```typescript
export const config = {
  id: "apiIntegration",
  retries: 3,
  metadata: {
    description: "Integrates with external API",
  },
};

export async function run(context: ActionContext) {
  const { apiKey } = context.request.metadata;

  try {
    const response = await fetch("https://api.example.com", {
      headers: { Authorization: `Bearer ${apiKey}` },
    });

    return await response.json();
  } catch (error) {
    throw new Error(`API request failed: ${error.message}`);
  }
}
```
