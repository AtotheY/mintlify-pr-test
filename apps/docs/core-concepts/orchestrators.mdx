---
title: "Orchestrators"
description: "Understanding Spinai orchestrators and how they coordinate AI workflows"
---

## What are Orchestrators?

Orchestrators are the decision-making engines in Spinai that coordinate the execution of actions. They analyze user input, determine which actions to run, and manage the overall flow of your AI agent.

## Built-in Orchestrators

### OpenAI Orchestrator

The default orchestrator uses OpenAI's models to make intelligent decisions:

```typescript
import { createOpenAIOrchestrator } from "spinai";

const orchestrator = createOpenAIOrchestrator({
  apiKey: process.env.OPENAI_API_KEY,
  model: "gpt-4-turbo-preview",
  systemPrompt: `You are an AI coordinator that helps users by:
    1. Analyzing their requests
    2. Selecting appropriate actions
    3. Determining when tasks are complete`,
});
```

#### Configuration Options

```typescript
interface OpenAIConfig {
  apiKey: string;
  model?: string; // Default: "gpt-4-turbo-preview"
  temperature?: number; // Default: 0.7
  systemPrompt: string; // Required
}
```

## Creating Custom Orchestrators

You can create custom orchestrators by implementing the `BaseOrchestrator` interface:

```typescript
interface BaseOrchestrator {
  initialize(): Promise<void>;
  decide(messages: OrchestratorMessage[]): Promise<OrchestratorDecision>;
  systemPrompt: string;
}
```

Example custom orchestrator:

```typescript
class MyOrchestrator implements BaseOrchestrator {
  constructor(private config: MyOrchestratorConfig) {}

  async initialize(): Promise<void> {
    // Setup code
  }

  async decide(messages: OrchestratorMessage[]): Promise<OrchestratorDecision> {
    // Your decision logic here
    return {
      actions: ["actionA", "actionB"],
      isDone: false,
      reasoning: "Need to process data",
    };
  }

  get systemPrompt(): string {
    return this.config.systemPrompt;
  }
}
```

## Decision Making

Orchestrators make decisions based on:

1. **User Input**: The original request
2. **Available Actions**: Registered action modules
3. **Previous Results**: Outcomes of executed actions
4. **System Context**: Overall state and configuration

### Decision Structure

```typescript
interface OrchestratorDecision {
  actions: string[]; // Actions to execute
  isDone: boolean; // Task completion status
  summary?: string; // Optional result summary
  reasoning?: string; // Explanation of decision
}
```

## Best Practices

### 1. System Prompt Design

Create clear, focused system prompts:

```typescript
const systemPrompt = `You are an AI coordinator that:
- Analyzes user requests carefully
- Chooses appropriate actions based on their descriptions
- Provides clear reasoning for decisions
- Marks tasks as complete only when objectives are met

Available actions:
${actionDescriptions}`;
```

### 2. Error Handling

Implement robust error handling:

```typescript
async decide(messages: OrchestratorMessage[]): Promise<OrchestratorDecision> {
  try {
    const decision = await this.makeDecision(messages);
    return this.validateDecision(decision);
  } catch (error) {
    return {
      actions: [],
      isDone: true,
      summary: "Error in decision making",
      reasoning: error.message
    };
  }
}
```

### 3. State Management

Maintain clean state between decisions:

```typescript
class StatefulOrchestrator implements BaseOrchestrator {
  private state: Map<string, any> = new Map();

  async decide(messages: OrchestratorMessage[]): Promise<OrchestratorDecision> {
    const context = this.buildContext(messages);
    const decision = await this.makeDecision(context);
    this.updateState(decision);
    return decision;
  }
}
```

## Advanced Topics

### Chain of Thought

Implement detailed reasoning:

```typescript
async makeDecision(context: DecisionContext): Promise<OrchestratorDecision> {
  return {
    actions: ["analyze", "summarize"],
    isDone: false,
    reasoning: `
    1. First, we need to analyze the text (analyze)
    2. Then, create a summary (summarize)
    3. Task will continue if refinement needed
    `
  };
}
```

### Action Dependencies

Handle complex workflows:

```typescript
function validateActionDependencies(
  actions: string[],
  availableActions: Record<string, ActionModule>
): void {
  // Dependency validation logic
}
```

## Examples

### Simple Task Orchestrator

```typescript
const simpleOrchestrator = createOpenAIOrchestrator({
  apiKey: process.env.OPENAI_API_KEY,
  systemPrompt: `You are a focused assistant that:
    1. Uses 'analyze' for text analysis
    2. Uses 'summarize' for creating summaries
    3. Completes tasks when a good summary is ready`,
});
```

### Complex Workflow Orchestrator

```typescript
const workflowOrchestrator = createOpenAIOrchestrator({
  apiKey: process.env.OPENAI_API_KEY,
  model: "gpt-4-turbo-preview",
  temperature: 0.5,
  systemPrompt: `You manage complex workflows by:
    1. Breaking tasks into subtasks
    2. Managing dependencies between actions
    3. Ensuring quality at each step
    4. Adapting to intermediate results`,
});
```
